Go Challenge 2
==============

This is my solution to the second Go Challenge
(http://golang-challenge.com/go-challenge2/)

The implementation is split in multiple files because I found it easier
to work with during development. I could have joined all the files into
a single one before submission, but I didn't.

SecureReader is an io.Reader that takes our private key and a partner's
public key and uses those to decrypt the data coming from an underlying
io.Reader. SecureWriter does the opposite: takes data from the user,
encrypts it and sends it to an underlying io.Writer.

SecureReader keeps a byte slice to avoid constant reallocations.  This
buffer's capacity is increased as needed, and it never shrinks.
SecureWriter follows a similar strategy, but the buffer's size is
increased by calling box.SealAfterPrecomputation if necessary.

I never got arround to implementing a buffer to allow for partial reads.
The idea would be to read from the underlying io.Reader, decrypt and
store in a buffer, which would then be read in whatever manner the
client wanted (byte-wise, in fixed chunks, entire messages at a time).
Part of the reason for not implementing this is because this can be
added as an additional io.Reader layer, something like this:

	func (r *BufferedReader) Read(p []byte) (int, error) {
		if r.buf.Len() >= len(p) {
			return r.buf.Read(p)
		}
		r.buf.Grow(MaxMsgLen)
		r.sr.Read(r.buf.Bytes()[r.buf.Len():])
		return r.buf.Read(p)
	}

or something along those lines, with r.buf being a bytes.Buffer -- the
idea being, read from the buffer as long as there's enough data, and
read entire messages from the secure reader into the buffer as needed.
Instead of piling all of this into SecureReader, add the layers as
required.

secureConn is the internal implenetation required to support secure
reads and writes over a net.Conn. It implements a (silly) handshake (to
detect errors early, instead of getting a whole bunch of
ErrDecryptionError after calling Read), and a exchange of public keys.

About TestSecureDial failing
----------------------------

TestSecureDial will fail every now and then (and almost always with
GOMAXPROCS>1) because that test starts a goroutine to act as a server,
which after accepting a connection, starts another goroutine to handle
the client.  The goroutine handling the connection writes a key to the
connection and then reads up to 2048 bytes as the message, after which
it performs a simple comparison and ends, closing the connection.

On the other hand, the client started by Dial tries to do the protocol
handshake which *writes* the protocol's identifier string and waits to
receive the server's public key and writes the client's public key.

What frequently happens is that the server closes the connection before
the client can finish the handshake, which causes the client connection
to return an error here:

	if _, err := fmt.Fprintf(conn, expected); err != nil {
		t.Fatal(err)
	}

The test is not failing because the client is sending the plaintext, but
because the connection is closed too soon, before the client actually
sends the cyphertext.
